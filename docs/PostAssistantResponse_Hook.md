# PostAssistantResponse Hook

## Overview

The `PostAssistantResponse` hook is called every time the assistant completes generating a response during the agent loop. This hook fires **after** tools are executed and the assistant message is added to conversation history, but **before** tool results are added back to history for the next iteration.

## When Does It Fire?

The hook is triggered at a specific point in the standard agent loop:

```
User message
  â†“
LLM generates response (with/without tool calls)
  â†“
Tools execute (if any ToolUse blocks present)
  â†“
Assistant message added to history
  â†“
ðŸ”¥ PostAssistantResponse HOOK FIRES HERE ðŸ”¥
  â†“
Tool results added to history (if any)
  â†“
Loop continues or ends
```

### Example Flow

In a typical multi-turn interaction:

```
User: "Help me analyze these files"
  â†’ LLM response with 5 tool calls
  â†’ 5 tools execute
  â†’ Assistant message saved to history
  â†’ [HOOK #1 FIRES] - sees 5 ToolUse blocks

  â†’ 5 tool results added to history
  â†’ LLM response with 3 tool calls
  â†’ 3 tools execute
  â†’ Assistant message saved to history
  â†’ [HOOK #2 FIRES] - sees 3 ToolUse blocks

  â†’ 3 tool results added to history
  â†’ LLM response with final text (no tools)
  â†’ Assistant message saved to history
  â†’ [HOOK #3 FIRES] - sees text content
  â†’ Turn complete
```

The hook fires **3 times** - once per LLM generation.

## Hook Context

The hook receives a `HookContext` with the following key fields:

| Field | Type | Description |
|-------|------|-------------|
| `event` | `HookEvent` | Always `PostAssistantResponse` |
| `internals` | `&mut AgentInternals` | Full access to agent state, session, permissions |
| `assistant_content` | `Option<Vec<ContentBlock>>` | The content blocks generated by the assistant |
| `stop_reason` | `Option<StopReason>` | Why the LLM stopped (EndTurn, ToolUse, MaxTokens, etc.) |

### Content Blocks

The `assistant_content` contains the raw response from the LLM, which may include:

- **Text blocks**: Text generated by the assistant
- **Thinking blocks**: Extended thinking content (if thinking is enabled)
- **ToolUse blocks**: Tool calls requested by the assistant

You can inspect these blocks to understand what the assistant is doing.

## Use Cases

### 1. Logging and Monitoring

Track all assistant responses for debugging, analytics, or audit purposes:

```rust
use shadow_agent_sdk::hooks::{HookRegistry, HookEvent, HookResult};
use shadow_agent_sdk::llm::ContentBlock;

let mut hooks = HookRegistry::new();

hooks.add(HookEvent::PostAssistantResponse, |ctx| {
    if let Some(ref content) = ctx.assistant_content {
        // Count different types of content
        let text_blocks = content.iter()
            .filter(|b| matches!(b, ContentBlock::Text { .. }))
            .count();
        let tool_blocks = content.iter()
            .filter(|b| matches!(b, ContentBlock::ToolUse { .. }))
            .count();
        let thinking_blocks = content.iter()
            .filter(|b| matches!(b, ContentBlock::Thinking { .. }))
            .count();

        tracing::info!(
            "Turn {}: {} text, {} tools, {} thinking blocks - stopped: {:?}",
            ctx.current_turn(),
            text_blocks,
            tool_blocks,
            thinking_blocks,
            ctx.stop_reason
        );
    }

    HookResult::none()
});
```

### 2. External Notifications

Send notifications when the assistant uses specific tools:

```rust
hooks.add(HookEvent::PostAssistantResponse, |ctx| {
    if let Some(ref content) = ctx.assistant_content {
        // Check if assistant is calling any write operations
        let has_write_tools = content.iter().any(|block| {
            if let ContentBlock::ToolUse { name, .. } = block {
                name == "Write" || name == "Edit" || name == "Bash"
            } else {
                false
            }
        });

        if has_write_tools {
            // Send notification to external service
            // send_slack_notification("Agent is modifying files!");
            tracing::warn!("Assistant requested write operations");
        }
    }

    HookResult::none()
});
```

### 3. Conversation Analytics

Analyze conversation patterns and save metrics:

```rust
use std::collections::HashMap;

hooks.add(HookEvent::PostAssistantResponse, |ctx| {
    if let Some(ref content) = ctx.assistant_content {
        // Track tool usage statistics
        let mut tool_counts: HashMap<String, u32> = HashMap::new();

        for block in content {
            if let ContentBlock::ToolUse { name, .. } = block {
                *tool_counts.entry(name.clone()).or_insert(0) += 1;
            }
        }

        // Store in metadata for later retrieval
        for (tool_name, count) in tool_counts {
            let key = format!("tool_usage_{}", tool_name);
            let current: u32 = ctx.get_metadata(&key)
                .and_then(|v| v.as_u64())
                .unwrap_or(0) as u32;

            ctx.set_metadata(&key, serde_json::json!(current + count));
        }
    }

    HookResult::none()
});
```

### 4. Response Validation

Check if the assistant's response meets certain criteria:

```rust
hooks.add(HookEvent::PostAssistantResponse, |ctx| {
    if let Some(ref content) = ctx.assistant_content {
        // Check for excessive tool calls
        let tool_count = content.iter()
            .filter(|b| matches!(b, ContentBlock::ToolUse { .. }))
            .count();

        if tool_count > 10 {
            tracing::warn!(
                "Assistant requested {} tools in a single response (turn {})",
                tool_count,
                ctx.current_turn()
            );
        }

        // Check for empty responses
        let has_content = content.iter().any(|block| {
            matches!(block, ContentBlock::Text { text, .. } if !text.trim().is_empty())
        });

        if !has_content && tool_count == 0 {
            tracing::error!("Assistant generated empty response!");
        }
    }

    HookResult::none()
});
```

### 5. Custom Logging to File

Save all assistant responses to a custom log file:

```rust
use std::fs::OpenOptions;
use std::io::Write;

hooks.add(HookEvent::PostAssistantResponse, |ctx| {
    if let Some(ref content) = ctx.assistant_content {
        let session_id = ctx.session_id();
        let turn = ctx.current_turn();

        // Format the response
        let mut log_entry = format!("\n=== Turn {} ===\n", turn);

        for block in content {
            match block {
                ContentBlock::Text { text, .. } => {
                    log_entry.push_str(&format!("TEXT: {}\n", text));
                }
                ContentBlock::ToolUse { name, .. } => {
                    log_entry.push_str(&format!("TOOL: {}\n", name));
                }
                ContentBlock::Thinking { thinking, .. } => {
                    log_entry.push_str(&format!("THINKING: {}\n", thinking));
                }
                _ => {}
            }
        }

        log_entry.push_str(&format!("STOP_REASON: {:?}\n", ctx.stop_reason));

        // Write to file
        if let Ok(mut file) = OpenOptions::new()
            .create(true)
            .append(true)
            .open(format!("assistant_log_{}.txt", session_id))
        {
            let _ = file.write_all(log_entry.as_bytes());
        }
    }

    HookResult::none()
});
```

## Accessing History

Since the hook fires **after** the assistant message is added to history, you can access it through the session:

```rust
hooks.add(HookEvent::PostAssistantResponse, |ctx| {
    // Get the most recent message (the assistant's response just added)
    let history = ctx.messages();

    if let Some(last_message) = history.last() {
        tracing::info!("Last message role: {}", last_message.role);
        // Inspect or modify the message in history if needed
    }

    HookResult::none()
});
```

## Modifying History (Advanced)

While primarily designed for observation, the hook has full access to `internals`, allowing you to modify the conversation history if needed:

```rust
hooks.add(HookEvent::PostAssistantResponse, |ctx| {
    // Example: Add a system reminder after certain responses
    if let Some(ref content) = ctx.assistant_content {
        let has_many_tools = content.iter()
            .filter(|b| matches!(b, ContentBlock::ToolUse { .. }))
            .count() > 5;

        if has_many_tools {
            // This is advanced usage - be careful modifying history!
            // You'd need to use async access to the session
            tracing::info!("Consider adding a reminder about tool usage");
        }
    }

    HookResult::none()
});
```

**Note**: Modifying history requires async session access and should be done carefully to avoid breaking the conversation flow.

## Integration with Agent Config

Add the hooks to your agent configuration:

```rust
use shadow_agent_sdk::agent::AgentConfig;
use shadow_agent_sdk::hooks::{HookRegistry, HookEvent, HookResult};

// Create hook registry
let mut hooks = HookRegistry::new();

// Add PostAssistantResponse hook
hooks.add(HookEvent::PostAssistantResponse, |ctx| {
    tracing::info!("Assistant completed response generation");
    HookResult::none()
});

// Create agent config with hooks
let config = AgentConfig::new("You are a helpful assistant")
    .with_tools(tools)
    .with_hooks(hooks);

// Create and run agent
let agent = StandardAgent::new(config, llm);
```

## Important Notes

### Timing
- Hook fires **after** tools execute, not before
- The assistant message is already in history when the hook runs
- Tool results are **not yet** in history (they're added after the hook)

### Limitations
- You **cannot** modify the `content_blocks` or `stop_reason` that were already generated
- You **can** access and modify the session history via `internals.session`
- You **can** read/write metadata for tracking purposes

### Performance
- Keep hook logic fast - it runs in the hot path of the agent loop
- Avoid blocking operations - spawn tasks for heavy work
- Be mindful of logging overhead in production

### Stop Reasons
The `stop_reason` field tells you why the LLM stopped generating:

| Stop Reason | Meaning |
|-------------|---------|
| `EndTurn` | Normal completion |
| `ToolUse` | Stopped to execute tools |
| `MaxTokens` | Hit token limit |
| `StopSequence` | Hit a stop sequence |
| `PauseTurn` | Model paused (rare) |
| `Refusal` | Model refused to respond |

## Complete Example

Here's a complete example that combines multiple use cases:

```rust
use shadow_agent_sdk::agent::{AgentConfig, StandardAgent};
use shadow_agent_sdk::hooks::{HookRegistry, HookEvent, HookResult};
use shadow_agent_sdk::llm::{ContentBlock, StopReason};

fn create_agent_with_monitoring() -> StandardAgent {
    let mut hooks = HookRegistry::new();

    // Add comprehensive response monitoring
    hooks.add(HookEvent::PostAssistantResponse, |ctx| {
        if let Some(ref content) = ctx.assistant_content {
            // 1. Log basic stats
            let text_count = content.iter()
                .filter(|b| matches!(b, ContentBlock::Text { .. }))
                .count();
            let tool_count = content.iter()
                .filter(|b| matches!(b, ContentBlock::ToolUse { .. }))
                .count();

            tracing::info!(
                "[Turn {}] Response: {} text blocks, {} tool calls, stop: {:?}",
                ctx.current_turn(),
                text_count,
                tool_count,
                ctx.stop_reason
            );

            // 2. Track tool usage in metadata
            for block in content {
                if let ContentBlock::ToolUse { name, .. } = block {
                    let key = format!("tool_usage_{}", name);
                    let current: u64 = ctx.get_metadata(&key)
                        .and_then(|v| v.as_u64())
                        .unwrap_or(0);
                    ctx.set_metadata(&key, serde_json::json!(current + 1));
                }
            }

            // 3. Warn on potential issues
            if tool_count > 10 {
                tracing::warn!("High tool usage: {} tools in one response", tool_count);
            }

            if matches!(ctx.stop_reason, Some(StopReason::MaxTokens)) {
                tracing::warn!("Response truncated due to max tokens");
            }

            // 4. Count total responses
            let total_responses: u64 = ctx.get_metadata("total_responses")
                .and_then(|v| v.as_u64())
                .unwrap_or(0);
            ctx.set_metadata("total_responses", serde_json::json!(total_responses + 1));
        }

        HookResult::none()
    });

    // Create agent with hooks
    let config = AgentConfig::new("You are a helpful assistant")
        .with_hooks(hooks);

    StandardAgent::new(config, llm_provider)
}
```

## See Also

- [Hook System Overview](../src/hooks/mod.rs) - General hook documentation
- [HookEvent Types](../src/hooks/types.rs) - All available hook events
- [Standard Agent Loop](../src/agent/standard_loop.rs) - How the agent loop works
